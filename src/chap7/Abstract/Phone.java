package chap7.Abstract;

abstract class Phone { //추상클래스

    public String owner;

    public Phone() {}  //부모클래스 혹은 추상클래스에서 기본생성자 반드시 만들어주자. 오류안나고 확실하게.
    public Phone(String owner) {
        this.owner = owner;
    }

    public void turnOn() {
        System.out.println("폰 전원을 켭니다.");
    }
    public void  turnOff() {
        System.out.println("폰 전원을 끕니다.");
    }
}


/*
객체를 직접 생성할 수 있는 클래스를 실체클래스라고 한다면, 이 클래스들의 공통적인 특성(필드와 메소드)을 추출해서 선언한 클래스를 추상클래스!
추상클래스는 부모클래스로만 쓸 수 있다. 그러면 실체클래스가 자식이겠지.

new 연산자로 직접 생성자를 호출할 수는 없지만(추상클래스타입의 객체를 만들 수는 없지만), 자식 객체가 생성될 때 super()를 호출해서
추상클래스 객체를 생성하므로 추상클래스도 반드시 생성자가 있어야 한다.

자동차를 설계할 때에는 일반적인(not 특정한) 타이어 규격에 맞추어서 작성해야 한다. 일반적인 규격을 준수하는 어떠한 것이든 부착할 수 있도록.
여기서 타이어 규격은 타이어의 추상클래스이고, 타이어 규격을 준수하는 한국타이어나 금호타이어는 추상클래스를 상속하는 타이어의 실체클래스!

코더가 작성해야 할 클래스가 다수이고 이 클래스들이 동일한 필드와 메소드를 가져야 할 경우, 설계자는 이 내용들을 추려내어 추상클래스로
설계 규격을 만드는게 좋다. 여러 코더들이 각자의 클래스를 만들면서 데이터와 기능이 같지만 이름만 다른경우가 생길 수 있다.
코더에게 추상클래스를 상속해서 구체적인 클래스를 만들도록 요청하면 된다.
이러면 객체마다 사용방법이 달라져서 혼돈이 온다. 이걸 방지하고자 공통된 필드와 메소드의 이름을 통일할 목적, 실체클래스 작성시 시간절약 위해서!
*/