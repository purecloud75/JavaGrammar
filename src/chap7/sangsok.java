package chap7;

public class sangsok {
}

/*
자식은 상속을 통해서 부모가 물려준 것을 자연스럽게 이용 가능하다.
상속은 이미 잘 개발된 클래스를 재사용해서 새로운 클래스를 만들기 때문에, 중복되는 코드를 줄여줍니다.
상속을 이용하면 부모 클래스의 수정으로 모든 자식 클래스들도 수정되는 효과를 가져오기에 유지 보수 시간을 최소화할 수도 있습니다.
프로그램에서는 자식이 부모를 선택한다.

메소드 재정의는 자식클래스에서 부모클래스의 메소드를 다시 정의하는 것이다. 단 접근제한을 더 강하게 재정의 할 수 없다. public -> private X!
재정의된 메소드는 자식클래스에서 호출된다. 부모객체의 메소드는 숨겨지기 때문에.
@Override 를 입력함으로써 확실히 얘는 메소드재정의한거다라고 알릴 수 있지만, 사실 자식클래스의 메소드입장에서는
부모클래스의 메소드와 이름, 시그니처(매개변수의 타입과 개수)만 똑같다면 (+접근제한 더 약하거나 같게) 얼마든지 메소드재정의이다!!!

final 클래스는 최종적인 클래스이므로 상속할 수 없다. 즉 부모클래스로서의 자격이 없다.
final 메소드는 최종적인 메소드이므로 재정의 될 수 없다. 즉 자식클래스에서 재정의할 수 없는 메소드이다.
final 필드는 선언과 동시에 초기화 혹은 생성자를 통한 초기화를 거치면 그 이후로 수정할 수 없다.
이렇게 final 키워드는 3가지의 경우에서 쓰인다.

클래스의 변환은 상속 관계에 있는 클래스 사이에서 발생합니다. 자식은 부모타입으로 자동타입변환.
부모 타입으로 자동타입변환이 된 이후에는 부모클래스에 선언된 필드와 메소드만 접근이 가능하다.
비록 참조타입변수는 자식 객체를 참조하지만 변수로 접근 가능한 멤버는 오로지 부모클래스 멤버로만 한정된다.
그러나 예외가 있는게, 메소드가 자식클래스에서 재정의 되었다면 자식클래스의 메소드가 대신 호출된다. -> 다형성 의 기초지식
Cat cat = new Cat();   Animal animal = cat;  이러면 두 참조타입변수는 동일한 Cat 객체를 참조합니다.
animal 은 cat 에 할당되어있는 Cat 클래스타입의 객체의 주소값을 할당받는 것이고, animal 은 비로소 참조할 수 있는 객체를 얻은 것이다.
객체의 주소값을 받음으로써 말이다. 하지만 이렇게 자동타입변환이 일어나면 부모클래스의 멤버에만 접근가능하다. 단 메소드재정의하면 자식메소드 접근!

객체는 부품이다. 마치 자동차의 타이어 4개가 각객의 객체 4개라고 보면 된다.
 */